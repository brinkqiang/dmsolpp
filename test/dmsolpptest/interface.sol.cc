/********************************************************************
**       This cc file is generated by program,                     **
**            Please do not change it directly.                    **
**                   Auther: brinkqiang                            **
********************************************************************/
// source: interface.pkg

#include "interface.sol.h"
#include "sol/sol.hpp"

#include "object.h"

#include "creature.h"

#include "player.h"

#include "common/types.h"

#include "common/enum.h"

#include "common/macros.h"

#include "common/struct.h"

namespace lua_module_interface
{
    static sol::table require_api(sol::this_state L)
    {
        sol::state_view lua(L);
        sol::table module = lua.create_table();

        module.new_usertype<CObject>(
            "CObject"
            , sol::constructors<CObject()>()
            , sol::meta_function::garbage_collect, sol::destructor([](CObject& temp) { temp.~CObject(); })
            , sol::base_classes, sol::bases<>()
            , "GetObjID", &CObject::GetObjID
            , "SetObjID", &CObject::SetObjID
            
            );
        module.new_usertype<CCreature>(
            "CCreature"
            , sol::constructors<CCreature()>()
            , sol::meta_function::garbage_collect, sol::destructor([](CCreature& temp) { temp.~CCreature(); })
            , sol::base_classes, sol::bases<CObject>()
            , "SetHP", &CCreature::SetHP
            , "SetMP", &CCreature::SetMP
            , "GetHP", &CCreature::GetHP
            , "GetMP", &CCreature::GetMP
            
            );
        module.set_function("GNextID",&GNextID);
        module.new_usertype<CPlayer>(
            "CPlayer"
            , sol::constructors<CPlayer(), CPlayer(int,std::string), CPlayer(std::string)>()
            , sol::meta_function::garbage_collect, sol::destructor([](CPlayer& temp) { temp.~CPlayer(); })
            , sol::base_classes, sol::bases<CCreature,CObject>()
            , "DoAction", &CPlayer::DoAction
            , "Init", &CPlayer::Init
            , "OnChange", &CPlayer::OnChange
            , "NotChange", &CPlayer::NotChange
            , "SystemChange", &CPlayer::SystemChange
            , "LoadFromDB", &CPlayer::LoadFromDB
            , "SaveDB", &CPlayer::SaveDB
            , "NextID", &CPlayer::NextID
            
            );
        module.new_usertype<STaskInfo>(
            "STaskInfo"
            , sol::constructors<STaskInfo()>()
            , sol::meta_function::garbage_collect, sol::destructor([](STaskInfo& temp) { temp.~STaskInfo(); })
            , sol::base_classes, sol::bases<>()
            
            , "nTaskID", &STaskInfo::nTaskID
            , "nTaskState", &STaskInfo::nTaskState
            , "nTaskCondition", &STaskInfo::nTaskCondition
            );
        module.new_usertype<SPos>(
            "SPos"
            , sol::constructors<SPos(), SPos(int,int,int)>()
            , sol::meta_function::garbage_collect, sol::destructor([](SPos& temp) { temp.~SPos(); })
            , sol::base_classes, sol::bases<>()
            
            , "x", &SPos::x
            , "y", &SPos::y
            , "z", &SPos::z
            );
        return module;
    }
}

LUA_API int luaopen_interface(lua_State* L)
{
    return sol::stack::call_lua(L, 1, lua_module_interface::require_api);
}

LUA_API int require_interface(lua_State* L)
{
    luaL_requiref(L, "interface", luaopen_interface, 0);
    printf("lua module: require interface\n");
    return 1;
}
